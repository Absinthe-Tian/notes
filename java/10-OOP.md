---
title: 10.Java面向对象
date: 2024-03-27 13:15:45
categories: Java语言
tags:
  - OOP
  - 面向对象
  - 封装
  - 继承
  - 多肽
---

Java 是一种面向对象的编程语言，它的设计思想基于对象的概念。面向对象编程 (OOP) 是一种软件开发范式，它将程序设计构建在对象的概念之上，通过对数据和操作进行封装，实现了代码的模块化、重用性和可维护性。

# 类

类：是定义对象的模板，是对象共同特征的描述。

Java Bean类：用来描述一类事物的类，不含main方法。

测试类：用来创建Java Bean类的对象并进行赋值调用的类，包含main方法。

工具类：帮助我们做一些操作，但是不描述任何事物的类（私有构造方法，方法静态化）。

## 类定义

```java
修饰符 class 类名{
  1、成员变量（代指属性，一般为名词）
  2、成员方法（代指行为，一般为动词）
  3、构造器
  4、代码块
  5、内部类
}
```

修饰符：

1. **public**：表示该类是公共的，可以被任何其他类访问。
2. **default（无修饰符）**：默认的访问修饰符，类在同一包内可见，但在不同包中不可见。
3. **final**：表示该类是最终的，不能被继承。
4. **abstract**：表示该类是抽象类，不能被实例化，只能被继承。可以包含抽象方法，子类必须实现这些抽象方法。
5. **strictfp**：确保浮点计算的结果在不同平台上一致。通常用于科学计算或需要精确计算的场景。
6. **final abstract**：Java 中不允许同时使用 `final` 和 `abstract` 修饰符。它们具有相互排斥的含义。`final` 表示最终的，不能被继承，而 `abstract` 表示抽象的，必须被继承并实现。

注意：==一个Java文件中可以定义多个类，但只能有一个类被public修饰，且public修饰的类名必须与文件名一致==（实际开发中建议一个文件一个类）。

## 成员变量

Java类中的成员变量代指该类拥有的属性。

```java
修饰符 数据类型 变量名;
```

> 可指定初始化值，但一般无需指定，存在默认值。

修饰符：

1. **public**：可以被任何其他类访问。其属性在整个应用程序中都是可见的。
2. **private**：只能被声明它们的类访问。属性对于类的使用者是隐藏的（需提供getter和setter方法）。
3. **protected**：可以被同一包内的其他类访问。可以被不同包下的子类访问。
4. **default**（包级别，默认修饰符）：如果没有指定修饰符，则默认为包级别，只能被同一包中的其他类访问。

此外，还有一些其他修饰符，它们与属性的行为和内存分配有关，但不常用于修饰类的属性，主要用于方法和类级别的修饰。

- **static**：用于创建类变量和方法，它们与类相关联，而不是与类的每个实例相关联。
- **final**：表示一个属性的值只能被赋值一次，且不能再次修改。
- **volatile**：用于标记属性，确保线程之间的可见性，即当一个线程修改了这个属性的值，其他线程能够立即看到最新的值。
- **transient**：用于标记属性，表示在序列化过程中忽略该属性，不会将其持久化保存。

## 成员方法

Java类中的成员方法代指该类拥有的行为。

```java
修饰符 返回值类型 方法名(该类 this, 形参类表){
  方法体
}
```

> 非静态方法可使用隐藏`this`来访问成员变量，本质是调用者的地址值的变量。
>
> 可以使用`super`来访问父类成员变量，本质是父类存储空间。

修饰符：

1. **public**：公共方法，可以被任何其他类访问。
2. **private**：私有方法，只能在声明它们的类内部访问。
3. **protected**：受保护方法，可以被同一包内的其他类访问。可以被不同包下的子类访问。
4. **default**（包级别，默认修饰符）：如果没有指定修饰符，则默认为包级别，只能被同一包中的其他类访问。

除了上述访问修饰符，类方法还可以使用其他修饰符，这些修饰符通常用于控制方法的行为或内存分配：

- **static**：静态方法（只能访问静态/静态区），不依赖于任何特定的对象实例，可以直接通过类名调用。
- **abstract**：抽象方法，只有方法的声明，没有方法体，必须在抽象类中声明。子类必须实现（重写）抽象方法。
- **final**：最终方法，表示该方法不能被子类重写。
- **synchronized**：同步方法，用于多线程环境，确保同时只有一个线程可以访问该方法。
- **native**：声明该方法是由本地代码实现的方法，通常是使用其他语言（如C/C++）实现的方法。
- **strictfp**：严格浮点数（strict floating point）方法，确保在不同的平台上进行浮点数计算时产生相同的结果。

## 构造方法

Java在创建对象的时候，可以在构造方法中，给成员变量进行赋值初始化（由虚拟机自动调用）。

```java
修饰符 方法名(形参列表){
  方法体
}
```

注意：

1. 方法名与类名相同，且大小写敏感。
2. 无返回值类型及具体返回值。
3. 如果未定义构造方法，系统将提供一个默认的无参的构造方法（推荐手动定义构造方法）。

修饰符：

1. **public**：公共构造器，可以被任何其他类调用。
2. **protected**：受保护构造器，可以被同一包内的其他类以及不同包下的子类调用。
3. **default**（包级别，默认修饰符）：如果没有指定修饰符，则默认为包级别，只能被同一包中的其他类调用。
4. **private**：私有构造器，只能在声明它们的类内部调用。

## 标准的Java Bean类

1. 类名要见名知意。
2. 成员变量使用`private`修饰。
3. 提供至少两个构造方法（无参及全参）。
4. 成员方法需要提供对应的getter和setter，有其他行为也需定义。

IDEA可安装`ptg`插件，[Command]{.kbd} + [Shift]{.kbd} + [,]{.kbd} 一键生成。

## 包

就说文件夹。用来管理各种不同功能的Java类，方便后期维护。

命名规则：域名反写 + 包作用，全部英文小写，见名知意。

包名：

```java
package com.absinthe.domain;
```

全类名（全限定名）：包名.类名

导包：

```java
import com.absinthe.domain.类名;
```

* 同一个包的类，不需要导包。
* java.lang不需要导包。
* 同时使用多个包中的同类名，需要使用全类名。

## 抽象

抽象类是一种不能实例化的类，它只能被继承。

```java
public abstract class 抽象类 {
  public abstract 返回值类型 抽象方法(参数列表);
}
```

注意：

* 抽象类不能实例化。
* 抽象类不一定有抽象方法，有抽象方法的一定是抽象类。
* 可以有构造方法。
* 抽象类的子类，要么重写所有抽象方法，要么仍为抽象类。

## 接口

接口就是一种规则，是对==行为==的抽象，不属于某一类事物。

定义：

```java
public interface 接口名 {}
```

实现：

```java
public class 类名 implements 接口名 {}
```

注意：

* 接口不能实例化。
* 接口的子类要么重写接口中的所有抽象方法，要么是抽象类。
* 接口和类的实现关系，可以是单实现，也可以是多实现。
* 实现类还可以在继承一个类的同时实现多个接口。

```java
public class 类名 extends 父类 implements 接口1, 接口2 {}
```

成员变量：只能是常量，默认修饰符`public static final`。

构造方法：无。

成员方法：只能是抽象方法，默认修饰符`public abstract`。

默认方法（jdk7以后）：使用`default`关键字，不强制被重写，重写需去掉`default`，默认方法名有重复时，必须重写。

静态方法（jdk7以后）：使用`static`关键字，只能通过接口名调用，实现类及实例不可调用，不能被重写。

私有方法（jdk9以后）：使用`private`关键字，只能抽取重复代码供接口内其他方法使用，分默认私有方法和静态私有方法。

## 内部类

内部类表示的事物是外部类的一部分，单独出现没有任何意义。

内部类可以直接访问外部类的成员，包括私有。

外部类要访问内部类成员，必须创建实例。

分类：成员内部类、静态内部类、局部内部类、匿名内部类。

jdk16以后内部类支持静态变量。

获取成员内部类对象

内部类获取外部类成员变量：`Outer.this.成员变量`，本质是指向外部类实例的地址。

方式一：在外部类中编写提供内部类的方法。

方式二：同一包下可直接创建`外部类.内部类 对象名 = 外部类对象.内部类对象;`

静态内部类只能访问外部类的静态变量和静态方法，如果访问非静态需要创建外部类对象。

创建静态内部类对象：`外部类.内部类 对象名 = new 外部类.内部类()`

调用静态内部类方法

非静态方法：先创建对象，使用对象调用。

静态方法：`外部类.内部类.方法名()`

局部内部类：定义在方法中的内部类，外界无法直接访问，需要在方法内部创建对象使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

匿名内部类（实现类只使用一次）：隐藏了类名的内部类，可以写在成员位置，也可以写在局部位置。

```java
new 接口/父类(){
  重写方法;
}
```

> 该内部类实现接口/继承父类，重写方法，并创建了一个该内部类的对象。

# 对象

对象：是类的实例，是真实存在类中的个体。

## 实例化及访问

1. 对象实例化

```java
类名 对象名 = new 类名(构造参数);
```

2. 对象属性及方法

```java
对象名.属性名
对象名.方法名()
```

## 内存

创建一个对象

1. 加载class文件
2. 定义局部变量（赋值语句左边）
3. 在堆空间开辟空间
4. 默认初始化
5. 显式初始化
6. 构造方法初始化
7. 将堆空间的地址值赋值给左边的变量（赋值语句右边）

# 三大特性

## 封装

指的是将对象的属性和方法组合成一个单一的单元，并对外部隐藏对象的实现细节。封装通过将数据隐藏在对象内部，同时提供公共的方法来访问和操作数据，从而实现了数据的安全性和灵活性，降低学习成本。

对象代表什么，就得封装对应的数据，并提供数据对应的行为。

## 继承

在Java中，继承是面向对象编程中的重要概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，子类可以获得父类的所有==非私有==属性和方法，并且可以在此基础上添加新的属性和方法，或者修改父类的行为。

```java
class Subclass extends Superclass {
    // 子类的属性和方法
}
```

> Object是所有类的直接或间接的基类。

注意：Java中只支持单继承，即一个子类只能继承一个父类，不支持多继承，但是支持多层继承。

成员变量：子类会继承父类所有的成员变量，但是会有访问权限限制，可以使用getter和setter进行访问。

虚方法：非private、非static、非final修饰的方法。

虚方法表：父类的虚方法会形成一个虚方法表，继承给子类，子类再加入自己的虚方法，形成自己的虚方法表，继续继承给子子类。优化了继承方法性能。

继承特点：就近原则。

==方法重写==：当父类的方法不能满足子类现在的需求时，需要进行方法重写（使用`@Override`重写注解，方法声明与父类一致，本质覆盖虚方法表）。

构造方法：构造方法不能被继承，但是子类的构造方法中，第一行默认有隐藏的`super()`来调用父类的构造方法，如要调用父类有参构造需要手动编写`super(参数列表)`。

## 多态

它允许不同类的对象对同一消息做出不同的响应。在Java中，多态性通过方法的重写（Override）和方法的重载（Overload）来实现。

前提：有继承/实现关系、有父类引用指向子类、有方法重写

好处：使用父类作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

成员变量：编译看父类、运行看父类。

成员方法：编译看父类、运行看子类。

弊端（强制类型转换为子类可解决）：如果父类没有子类的特有方法，则调用不了。
